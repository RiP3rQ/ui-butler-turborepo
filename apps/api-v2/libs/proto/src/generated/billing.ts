// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.20.3
// source: billing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { messageTypeRegistry } from "./typeRegistry";

export const protobufPackage = "api.billing";

export interface User {
  $type: "api.billing.User";
  id: string;
  email: string;
}

export interface SetupUserRequest {
  $type: "api.billing.SetupUserRequest";
  user?: User | undefined;
}

export interface PurchasePackRequest {
  $type: "api.billing.PurchasePackRequest";
  user?: User | undefined;
  packId: string;
}

export interface GetUserCreditsRequest {
  $type: "api.billing.GetUserCreditsRequest";
  user?: User | undefined;
}

export interface UserCreditsResponse {
  $type: "api.billing.UserCreditsResponse";
  credits: number;
  userId: string;
}

export interface Empty {
  $type: "api.billing.Empty";
}

export const API_BILLING_PACKAGE_NAME = "api.billing";

function createBaseUser(): User {
  return { $type: "api.billing.User", id: "", email: "" };
}

export const User: MessageFns<User, "api.billing.User"> = {
  $type: "api.billing.User" as const,

  encode(
    message: User,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(User.$type, User);

function createBaseSetupUserRequest(): SetupUserRequest {
  return { $type: "api.billing.SetupUserRequest" };
}

export const SetupUserRequest: MessageFns<
  SetupUserRequest,
  "api.billing.SetupUserRequest"
> = {
  $type: "api.billing.SetupUserRequest" as const,

  encode(
    message: SetupUserRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupUserRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(SetupUserRequest.$type, SetupUserRequest);

function createBasePurchasePackRequest(): PurchasePackRequest {
  return { $type: "api.billing.PurchasePackRequest", packId: "" };
}

export const PurchasePackRequest: MessageFns<
  PurchasePackRequest,
  "api.billing.PurchasePackRequest"
> = {
  $type: "api.billing.PurchasePackRequest" as const,

  encode(
    message: PurchasePackRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.packId !== "") {
      writer.uint32(18).string(message.packId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PurchasePackRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchasePackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.packId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(PurchasePackRequest.$type, PurchasePackRequest);

function createBaseGetUserCreditsRequest(): GetUserCreditsRequest {
  return { $type: "api.billing.GetUserCreditsRequest" };
}

export const GetUserCreditsRequest: MessageFns<
  GetUserCreditsRequest,
  "api.billing.GetUserCreditsRequest"
> = {
  $type: "api.billing.GetUserCreditsRequest" as const,

  encode(
    message: GetUserCreditsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetUserCreditsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserCreditsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetUserCreditsRequest.$type, GetUserCreditsRequest);

function createBaseUserCreditsResponse(): UserCreditsResponse {
  return { $type: "api.billing.UserCreditsResponse", credits: 0, userId: "" };
}

export const UserCreditsResponse: MessageFns<
  UserCreditsResponse,
  "api.billing.UserCreditsResponse"
> = {
  $type: "api.billing.UserCreditsResponse" as const,

  encode(
    message: UserCreditsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.credits !== 0) {
      writer.uint32(8).int32(message.credits);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UserCreditsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCreditsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.credits = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(UserCreditsResponse.$type, UserCreditsResponse);

function createBaseEmpty(): Empty {
  return { $type: "api.billing.Empty" };
}

export const Empty: MessageFns<Empty, "api.billing.Empty"> = {
  $type: "api.billing.Empty" as const,

  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(Empty.$type, Empty);

export interface BillingServiceClient {
  setupUser(request: SetupUserRequest): Observable<Empty>;

  purchasePack(request: PurchasePackRequest): Observable<UserCreditsResponse>;

  getUserCredits(
    request: GetUserCreditsRequest,
  ): Observable<UserCreditsResponse>;
}

export interface BillingServiceController {
  setupUser(
    request: SetupUserRequest,
  ): Promise<Empty> | Observable<Empty> | Empty;

  purchasePack(
    request: PurchasePackRequest,
  ):
    | Promise<UserCreditsResponse>
    | Observable<UserCreditsResponse>
    | UserCreditsResponse;

  getUserCredits(
    request: GetUserCreditsRequest,
  ):
    | Promise<UserCreditsResponse>
    | Observable<UserCreditsResponse>
    | UserCreditsResponse;
}

export function BillingServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "setupUser",
      "purchasePack",
      "getUserCredits",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod("BillingService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod("BillingService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const BILLING_SERVICE_NAME = "BillingService";

export interface MessageFns<T, V extends string> {
  readonly $type: V;

  encode(message: T, writer?: BinaryWriter): BinaryWriter;

  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
