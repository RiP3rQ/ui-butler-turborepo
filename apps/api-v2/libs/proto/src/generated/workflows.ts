// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.20.3
// source: workflows.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { messageTypeRegistry } from "./typeRegistry";

export const protobufPackage = "api.workflows";

export interface User {
  $type: "api.workflows.User";
  id: string;
  email: string;
}

export interface Workflow {
  $type: "api.workflows.Workflow";
  id: number;
  name: string;
  description: string;
  userId: string;
  definition: string;
  status: string;
  executionPlan: string;
  creditsCost: number;
  createdAt: string;
  updatedAt: string;
}

export interface WorkflowExecution {
  $type: "api.workflows.WorkflowExecution";
  id: number;
  workflowId: number;
  userId: string;
  status: string;
  startedAt: string;
  endedAt: string;
  trigger: string;
  definition: string;
  createdAt: string;
}

export interface ExecutionPhase {
  $type: "api.workflows.ExecutionPhase";
  id: number;
  workflowExecutionId: number;
  userId: string;
  status: string;
  number: number;
  node: string;
  name: string;
  startedAt: string;
  endedAt: string;
}

export interface ExecutionLog {
  $type: "api.workflows.ExecutionLog";
  id: number;
  executionPhaseId: number;
  message: string;
  level: string;
  timestamp: string;
}

/** Request messages */
export interface GetAllUserWorkflowsRequest {
  $type: "api.workflows.GetAllUserWorkflowsRequest";
  user?: User | undefined;
}

export interface GetWorkflowByIdRequest {
  $type: "api.workflows.GetWorkflowByIdRequest";
  user?: User | undefined;
  workflowId: number;
}

export interface CreateWorkflowRequest {
  $type: "api.workflows.CreateWorkflowRequest";
  user?: User | undefined;
  name: string;
  description: string;
}

export interface DeleteWorkflowRequest {
  $type: "api.workflows.DeleteWorkflowRequest";
  user?: User | undefined;
  workflowId: number;
}

export interface DuplicateWorkflowRequest {
  $type: "api.workflows.DuplicateWorkflowRequest";
  user?: User | undefined;
  workflowId: number;
  name: string;
  description: string;
}

export interface PublishWorkflowRequest {
  $type: "api.workflows.PublishWorkflowRequest";
  user?: User | undefined;
  workflowId: number;
  flowDefinition: string;
}

export interface UnpublishWorkflowRequest {
  $type: "api.workflows.UnpublishWorkflowRequest";
  user?: User | undefined;
  workflowId: number;
}

export interface RunWorkflowRequest {
  $type: "api.workflows.RunWorkflowRequest";
  user?: User | undefined;
  workflowId: number;
  flowDefinition: string;
  componentId: string;
}

export interface UpdateWorkflowRequest {
  $type: "api.workflows.UpdateWorkflowRequest";
  user?: User | undefined;
  workflowId: number;
  definition: string;
}

export interface GetHistoricRequest {
  $type: "api.workflows.GetHistoricRequest";
  user?: User | undefined;
  workflowId: number;
}

export interface GetExecutionsRequest {
  $type: "api.workflows.GetExecutionsRequest";
  user?: User | undefined;
  executionId: number;
}

export interface GetPhaseRequest {
  $type: "api.workflows.GetPhaseRequest";
  user?: User | undefined;
  phaseId: number;
}

/** Response messages */
export interface WorkflowsResponse {
  $type: "api.workflows.WorkflowsResponse";
  workflows: Workflow[];
}

export interface WorkflowResponse {
  $type: "api.workflows.WorkflowResponse";
  workflow?: Workflow | undefined;
}

export interface RunWorkflowResponse {
  $type: "api.workflows.RunWorkflowResponse";
  url: string;
}

export interface WorkflowExecutionsResponse {
  $type: "api.workflows.WorkflowExecutionsResponse";
  executions: WorkflowExecution[];
}

export interface WorkflowExecutionDetailResponse {
  $type: "api.workflows.WorkflowExecutionDetailResponse";
  execution?: WorkflowExecution | undefined;
  phases: ExecutionPhase[];
}

export interface PhaseResponse {
  $type: "api.workflows.PhaseResponse";
  phase?: ExecutionPhase | undefined;
  logs: ExecutionLog[];
}

export const API_WORKFLOWS_PACKAGE_NAME = "api.workflows";

function createBaseUser(): User {
  return { $type: "api.workflows.User", id: "", email: "" };
}

export const User: MessageFns<User, "api.workflows.User"> = {
  $type: "api.workflows.User" as const,

  encode(
    message: User,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(User.$type, User);

function createBaseWorkflow(): Workflow {
  return {
    $type: "api.workflows.Workflow",
    id: 0,
    name: "",
    description: "",
    userId: "",
    definition: "",
    status: "",
    executionPlan: "",
    creditsCost: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const Workflow: MessageFns<Workflow, "api.workflows.Workflow"> = {
  $type: "api.workflows.Workflow" as const,

  encode(
    message: Workflow,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.definition !== "") {
      writer.uint32(42).string(message.definition);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.executionPlan !== "") {
      writer.uint32(58).string(message.executionPlan);
    }
    if (message.creditsCost !== 0) {
      writer.uint32(64).int32(message.creditsCost);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workflow {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.executionPlan = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.creditsCost = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(Workflow.$type, Workflow);

function createBaseWorkflowExecution(): WorkflowExecution {
  return {
    $type: "api.workflows.WorkflowExecution",
    id: 0,
    workflowId: 0,
    userId: "",
    status: "",
    startedAt: "",
    endedAt: "",
    trigger: "",
    definition: "",
    createdAt: "",
  };
}

export const WorkflowExecution: MessageFns<
  WorkflowExecution,
  "api.workflows.WorkflowExecution"
> = {
  $type: "api.workflows.WorkflowExecution" as const,

  encode(
    message: WorkflowExecution,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.startedAt !== "") {
      writer.uint32(42).string(message.startedAt);
    }
    if (message.endedAt !== "") {
      writer.uint32(50).string(message.endedAt);
    }
    if (message.trigger !== "") {
      writer.uint32(58).string(message.trigger);
    }
    if (message.definition !== "") {
      writer.uint32(66).string(message.definition);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowExecution {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endedAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.trigger = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(WorkflowExecution.$type, WorkflowExecution);

function createBaseExecutionPhase(): ExecutionPhase {
  return {
    $type: "api.workflows.ExecutionPhase",
    id: 0,
    workflowExecutionId: 0,
    userId: "",
    status: "",
    number: 0,
    node: "",
    name: "",
    startedAt: "",
    endedAt: "",
  };
}

export const ExecutionPhase: MessageFns<
  ExecutionPhase,
  "api.workflows.ExecutionPhase"
> = {
  $type: "api.workflows.ExecutionPhase" as const,

  encode(
    message: ExecutionPhase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.workflowExecutionId !== 0) {
      writer.uint32(16).int32(message.workflowExecutionId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.number !== 0) {
      writer.uint32(40).int32(message.number);
    }
    if (message.node !== "") {
      writer.uint32(50).string(message.node);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.startedAt !== "") {
      writer.uint32(66).string(message.startedAt);
    }
    if (message.endedAt !== "") {
      writer.uint32(74).string(message.endedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionPhase {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionPhase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowExecutionId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.number = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.node = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.endedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(ExecutionPhase.$type, ExecutionPhase);

function createBaseExecutionLog(): ExecutionLog {
  return {
    $type: "api.workflows.ExecutionLog",
    id: 0,
    executionPhaseId: 0,
    message: "",
    level: "",
    timestamp: "",
  };
}

export const ExecutionLog: MessageFns<
  ExecutionLog,
  "api.workflows.ExecutionLog"
> = {
  $type: "api.workflows.ExecutionLog" as const,

  encode(
    message: ExecutionLog,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.executionPhaseId !== 0) {
      writer.uint32(16).int32(message.executionPhaseId);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.level !== "") {
      writer.uint32(34).string(message.level);
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionLog {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.executionPhaseId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.level = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(ExecutionLog.$type, ExecutionLog);

function createBaseGetAllUserWorkflowsRequest(): GetAllUserWorkflowsRequest {
  return { $type: "api.workflows.GetAllUserWorkflowsRequest" };
}

export const GetAllUserWorkflowsRequest: MessageFns<
  GetAllUserWorkflowsRequest,
  "api.workflows.GetAllUserWorkflowsRequest"
> = {
  $type: "api.workflows.GetAllUserWorkflowsRequest" as const,

  encode(
    message: GetAllUserWorkflowsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAllUserWorkflowsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUserWorkflowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  GetAllUserWorkflowsRequest.$type,
  GetAllUserWorkflowsRequest,
);

function createBaseGetWorkflowByIdRequest(): GetWorkflowByIdRequest {
  return { $type: "api.workflows.GetWorkflowByIdRequest", workflowId: 0 };
}

export const GetWorkflowByIdRequest: MessageFns<
  GetWorkflowByIdRequest,
  "api.workflows.GetWorkflowByIdRequest"
> = {
  $type: "api.workflows.GetWorkflowByIdRequest" as const,

  encode(
    message: GetWorkflowByIdRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetWorkflowByIdRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkflowByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetWorkflowByIdRequest.$type, GetWorkflowByIdRequest);

function createBaseCreateWorkflowRequest(): CreateWorkflowRequest {
  return {
    $type: "api.workflows.CreateWorkflowRequest",
    name: "",
    description: "",
  };
}

export const CreateWorkflowRequest: MessageFns<
  CreateWorkflowRequest,
  "api.workflows.CreateWorkflowRequest"
> = {
  $type: "api.workflows.CreateWorkflowRequest" as const,

  encode(
    message: CreateWorkflowRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateWorkflowRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(CreateWorkflowRequest.$type, CreateWorkflowRequest);

function createBaseDeleteWorkflowRequest(): DeleteWorkflowRequest {
  return { $type: "api.workflows.DeleteWorkflowRequest", workflowId: 0 };
}

export const DeleteWorkflowRequest: MessageFns<
  DeleteWorkflowRequest,
  "api.workflows.DeleteWorkflowRequest"
> = {
  $type: "api.workflows.DeleteWorkflowRequest" as const,

  encode(
    message: DeleteWorkflowRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DeleteWorkflowRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(DeleteWorkflowRequest.$type, DeleteWorkflowRequest);

function createBaseDuplicateWorkflowRequest(): DuplicateWorkflowRequest {
  return {
    $type: "api.workflows.DuplicateWorkflowRequest",
    workflowId: 0,
    name: "",
    description: "",
  };
}

export const DuplicateWorkflowRequest: MessageFns<
  DuplicateWorkflowRequest,
  "api.workflows.DuplicateWorkflowRequest"
> = {
  $type: "api.workflows.DuplicateWorkflowRequest" as const,

  encode(
    message: DuplicateWorkflowRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DuplicateWorkflowRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  DuplicateWorkflowRequest.$type,
  DuplicateWorkflowRequest,
);

function createBasePublishWorkflowRequest(): PublishWorkflowRequest {
  return {
    $type: "api.workflows.PublishWorkflowRequest",
    workflowId: 0,
    flowDefinition: "",
  };
}

export const PublishWorkflowRequest: MessageFns<
  PublishWorkflowRequest,
  "api.workflows.PublishWorkflowRequest"
> = {
  $type: "api.workflows.PublishWorkflowRequest" as const,

  encode(
    message: PublishWorkflowRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    if (message.flowDefinition !== "") {
      writer.uint32(26).string(message.flowDefinition);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PublishWorkflowRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.flowDefinition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(PublishWorkflowRequest.$type, PublishWorkflowRequest);

function createBaseUnpublishWorkflowRequest(): UnpublishWorkflowRequest {
  return { $type: "api.workflows.UnpublishWorkflowRequest", workflowId: 0 };
}

export const UnpublishWorkflowRequest: MessageFns<
  UnpublishWorkflowRequest,
  "api.workflows.UnpublishWorkflowRequest"
> = {
  $type: "api.workflows.UnpublishWorkflowRequest" as const,

  encode(
    message: UnpublishWorkflowRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UnpublishWorkflowRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnpublishWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  UnpublishWorkflowRequest.$type,
  UnpublishWorkflowRequest,
);

function createBaseRunWorkflowRequest(): RunWorkflowRequest {
  return {
    $type: "api.workflows.RunWorkflowRequest",
    workflowId: 0,
    flowDefinition: "",
    componentId: "",
  };
}

export const RunWorkflowRequest: MessageFns<
  RunWorkflowRequest,
  "api.workflows.RunWorkflowRequest"
> = {
  $type: "api.workflows.RunWorkflowRequest" as const,

  encode(
    message: RunWorkflowRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    if (message.flowDefinition !== "") {
      writer.uint32(26).string(message.flowDefinition);
    }
    if (message.componentId !== "") {
      writer.uint32(34).string(message.componentId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RunWorkflowRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.flowDefinition = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.componentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(RunWorkflowRequest.$type, RunWorkflowRequest);

function createBaseUpdateWorkflowRequest(): UpdateWorkflowRequest {
  return {
    $type: "api.workflows.UpdateWorkflowRequest",
    workflowId: 0,
    definition: "",
  };
}

export const UpdateWorkflowRequest: MessageFns<
  UpdateWorkflowRequest,
  "api.workflows.UpdateWorkflowRequest"
> = {
  $type: "api.workflows.UpdateWorkflowRequest" as const,

  encode(
    message: UpdateWorkflowRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    if (message.definition !== "") {
      writer.uint32(26).string(message.definition);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UpdateWorkflowRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(UpdateWorkflowRequest.$type, UpdateWorkflowRequest);

function createBaseGetHistoricRequest(): GetHistoricRequest {
  return { $type: "api.workflows.GetHistoricRequest", workflowId: 0 };
}

export const GetHistoricRequest: MessageFns<
  GetHistoricRequest,
  "api.workflows.GetHistoricRequest"
> = {
  $type: "api.workflows.GetHistoricRequest" as const,

  encode(
    message: GetHistoricRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== 0) {
      writer.uint32(16).int32(message.workflowId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetHistoricRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHistoricRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workflowId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetHistoricRequest.$type, GetHistoricRequest);

function createBaseGetExecutionsRequest(): GetExecutionsRequest {
  return { $type: "api.workflows.GetExecutionsRequest", executionId: 0 };
}

export const GetExecutionsRequest: MessageFns<
  GetExecutionsRequest,
  "api.workflows.GetExecutionsRequest"
> = {
  $type: "api.workflows.GetExecutionsRequest" as const,

  encode(
    message: GetExecutionsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.executionId !== 0) {
      writer.uint32(16).int32(message.executionId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetExecutionsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.executionId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetExecutionsRequest.$type, GetExecutionsRequest);

function createBaseGetPhaseRequest(): GetPhaseRequest {
  return { $type: "api.workflows.GetPhaseRequest", phaseId: 0 };
}

export const GetPhaseRequest: MessageFns<
  GetPhaseRequest,
  "api.workflows.GetPhaseRequest"
> = {
  $type: "api.workflows.GetPhaseRequest" as const,

  encode(
    message: GetPhaseRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.phaseId !== 0) {
      writer.uint32(16).int32(message.phaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPhaseRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPhaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.phaseId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetPhaseRequest.$type, GetPhaseRequest);

function createBaseWorkflowsResponse(): WorkflowsResponse {
  return { $type: "api.workflows.WorkflowsResponse", workflows: [] };
}

export const WorkflowsResponse: MessageFns<
  WorkflowsResponse,
  "api.workflows.WorkflowsResponse"
> = {
  $type: "api.workflows.WorkflowsResponse" as const,

  encode(
    message: WorkflowsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.workflows) {
      Workflow.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflows.push(Workflow.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(WorkflowsResponse.$type, WorkflowsResponse);

function createBaseWorkflowResponse(): WorkflowResponse {
  return { $type: "api.workflows.WorkflowResponse" };
}

export const WorkflowResponse: MessageFns<
  WorkflowResponse,
  "api.workflows.WorkflowResponse"
> = {
  $type: "api.workflows.WorkflowResponse" as const,

  encode(
    message: WorkflowResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.workflow !== undefined) {
      Workflow.encode(message.workflow, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(WorkflowResponse.$type, WorkflowResponse);

function createBaseRunWorkflowResponse(): RunWorkflowResponse {
  return { $type: "api.workflows.RunWorkflowResponse", url: "" };
}

export const RunWorkflowResponse: MessageFns<
  RunWorkflowResponse,
  "api.workflows.RunWorkflowResponse"
> = {
  $type: "api.workflows.RunWorkflowResponse" as const,

  encode(
    message: RunWorkflowResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RunWorkflowResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunWorkflowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(RunWorkflowResponse.$type, RunWorkflowResponse);

function createBaseWorkflowExecutionsResponse(): WorkflowExecutionsResponse {
  return { $type: "api.workflows.WorkflowExecutionsResponse", executions: [] };
}

export const WorkflowExecutionsResponse: MessageFns<
  WorkflowExecutionsResponse,
  "api.workflows.WorkflowExecutionsResponse"
> = {
  $type: "api.workflows.WorkflowExecutionsResponse" as const,

  encode(
    message: WorkflowExecutionsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.executions) {
      WorkflowExecution.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WorkflowExecutionsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowExecutionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executions.push(
            WorkflowExecution.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  WorkflowExecutionsResponse.$type,
  WorkflowExecutionsResponse,
);

function createBaseWorkflowExecutionDetailResponse(): WorkflowExecutionDetailResponse {
  return { $type: "api.workflows.WorkflowExecutionDetailResponse", phases: [] };
}

export const WorkflowExecutionDetailResponse: MessageFns<
  WorkflowExecutionDetailResponse,
  "api.workflows.WorkflowExecutionDetailResponse"
> = {
  $type: "api.workflows.WorkflowExecutionDetailResponse" as const,

  encode(
    message: WorkflowExecutionDetailResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.execution !== undefined) {
      WorkflowExecution.encode(
        message.execution,
        writer.uint32(10).fork(),
      ).join();
    }
    for (const v of message.phases) {
      ExecutionPhase.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WorkflowExecutionDetailResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowExecutionDetailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execution = WorkflowExecution.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.phases.push(ExecutionPhase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  WorkflowExecutionDetailResponse.$type,
  WorkflowExecutionDetailResponse,
);

function createBasePhaseResponse(): PhaseResponse {
  return { $type: "api.workflows.PhaseResponse", logs: [] };
}

export const PhaseResponse: MessageFns<
  PhaseResponse,
  "api.workflows.PhaseResponse"
> = {
  $type: "api.workflows.PhaseResponse" as const,

  encode(
    message: PhaseResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.phase !== undefined) {
      ExecutionPhase.encode(message.phase, writer.uint32(10).fork()).join();
    }
    for (const v of message.logs) {
      ExecutionLog.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhaseResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.phase = ExecutionPhase.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logs.push(ExecutionLog.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(PhaseResponse.$type, PhaseResponse);

export interface WorkflowsServiceClient {
  getAllUserWorkflows(
    request: GetAllUserWorkflowsRequest,
  ): Observable<WorkflowsResponse>;

  getWorkflowById(
    request: GetWorkflowByIdRequest,
  ): Observable<WorkflowResponse>;

  createWorkflow(request: CreateWorkflowRequest): Observable<WorkflowResponse>;

  deleteWorkflow(request: DeleteWorkflowRequest): Observable<WorkflowResponse>;

  duplicateWorkflow(
    request: DuplicateWorkflowRequest,
  ): Observable<WorkflowResponse>;

  publishWorkflow(
    request: PublishWorkflowRequest,
  ): Observable<WorkflowResponse>;

  unpublishWorkflow(
    request: UnpublishWorkflowRequest,
  ): Observable<WorkflowResponse>;

  runWorkflow(request: RunWorkflowRequest): Observable<RunWorkflowResponse>;

  updateWorkflow(request: UpdateWorkflowRequest): Observable<WorkflowResponse>;

  getHistoricWorkflowExecutions(
    request: GetHistoricRequest,
  ): Observable<WorkflowExecutionsResponse>;

  getWorkflowExecutions(
    request: GetExecutionsRequest,
  ): Observable<WorkflowExecutionDetailResponse>;

  getWorkflowPhase(request: GetPhaseRequest): Observable<PhaseResponse>;
}

export interface WorkflowsServiceController {
  getAllUserWorkflows(
    request: GetAllUserWorkflowsRequest,
  ):
    | Promise<WorkflowsResponse>
    | Observable<WorkflowsResponse>
    | WorkflowsResponse;

  getWorkflowById(
    request: GetWorkflowByIdRequest,
  ):
    | Promise<WorkflowResponse>
    | Observable<WorkflowResponse>
    | WorkflowResponse;

  createWorkflow(
    request: CreateWorkflowRequest,
  ):
    | Promise<WorkflowResponse>
    | Observable<WorkflowResponse>
    | WorkflowResponse;

  deleteWorkflow(
    request: DeleteWorkflowRequest,
  ):
    | Promise<WorkflowResponse>
    | Observable<WorkflowResponse>
    | WorkflowResponse;

  duplicateWorkflow(
    request: DuplicateWorkflowRequest,
  ):
    | Promise<WorkflowResponse>
    | Observable<WorkflowResponse>
    | WorkflowResponse;

  publishWorkflow(
    request: PublishWorkflowRequest,
  ):
    | Promise<WorkflowResponse>
    | Observable<WorkflowResponse>
    | WorkflowResponse;

  unpublishWorkflow(
    request: UnpublishWorkflowRequest,
  ):
    | Promise<WorkflowResponse>
    | Observable<WorkflowResponse>
    | WorkflowResponse;

  runWorkflow(
    request: RunWorkflowRequest,
  ):
    | Promise<RunWorkflowResponse>
    | Observable<RunWorkflowResponse>
    | RunWorkflowResponse;

  updateWorkflow(
    request: UpdateWorkflowRequest,
  ):
    | Promise<WorkflowResponse>
    | Observable<WorkflowResponse>
    | WorkflowResponse;

  getHistoricWorkflowExecutions(
    request: GetHistoricRequest,
  ):
    | Promise<WorkflowExecutionsResponse>
    | Observable<WorkflowExecutionsResponse>
    | WorkflowExecutionsResponse;

  getWorkflowExecutions(
    request: GetExecutionsRequest,
  ):
    | Promise<WorkflowExecutionDetailResponse>
    | Observable<WorkflowExecutionDetailResponse>
    | WorkflowExecutionDetailResponse;

  getWorkflowPhase(
    request: GetPhaseRequest,
  ): Promise<PhaseResponse> | Observable<PhaseResponse> | PhaseResponse;
}

export function WorkflowsServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getAllUserWorkflows",
      "getWorkflowById",
      "createWorkflow",
      "deleteWorkflow",
      "duplicateWorkflow",
      "publishWorkflow",
      "unpublishWorkflow",
      "runWorkflow",
      "updateWorkflow",
      "getHistoricWorkflowExecutions",
      "getWorkflowExecutions",
      "getWorkflowPhase",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod("WorkflowsService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod("WorkflowsService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const WORKFLOWS_SERVICE_NAME = "WorkflowsService";

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
