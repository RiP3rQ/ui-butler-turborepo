// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.20.3
// source: users.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Timestamp } from "./google/protobuf/timestamp";
import { messageTypeRegistry } from "./typeRegistry";

export const protobufPackage = "api.users";

/** Common messages for Users */
export interface User {
  $type: "api.users.User";
  id: number;
  email: string;
  username: string;
  password?: string | undefined;
  refreshToken?: string | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
}

export interface CreateUserDto {
  $type: "api.users.CreateUserDto";
  email: string;
  password: string;
  username?: string | undefined;
}

export interface TokenPayload {
  $type: "api.users.TokenPayload";
  userId: string;
  email: string;
}

export interface Profile {
  $type: "api.users.Profile";
  id: number;
  userId: number;
  bio: string;
  location: string;
  website: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
}

export interface CreateProfileDto {
  $type: "api.users.CreateProfileDto";
  userId: number;
  bio: string;
  location: string;
  website: string;
}

export interface Empty {
  $type: "api.users.Empty";
}

export interface GetUsersResponse {
  $type: "api.users.GetUsersResponse";
  users: User[];
}

export interface GetCurrentUserRequest {
  $type: "api.users.GetCurrentUserRequest";
  user?: User | undefined;
}

export interface GetCurrentUserResponse {
  $type: "api.users.GetCurrentUserResponse";
  id: number;
  username?: string | undefined;
  email: string;
  avatar?: string | undefined;
}

export interface GetUserByEmailRequest {
  $type: "api.users.GetUserByEmailRequest";
  email: string;
}

export interface UpdateUserRequest {
  $type: "api.users.UpdateUserRequest";
  query?: TokenPayload | undefined;
  data?: ReceivedRefreshToken | undefined;
}

export interface ReceivedRefreshToken {
  $type: "api.users.ReceivedRefreshToken";
  refreshToken: string;
}

export const API_USERS_PACKAGE_NAME = "api.users";

function createBaseUser(): User {
  return { $type: "api.users.User", id: 0, email: "", username: "" };
}

export const User: MessageFns<User, "api.users.User"> = {
  $type: "api.users.User" as const,

  encode(
    message: User,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.password !== undefined) {
      writer.uint32(34).string(message.password);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(42).string(message.refreshToken);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(User.$type, User);

function createBaseCreateUserDto(): CreateUserDto {
  return { $type: "api.users.CreateUserDto", email: "", password: "" };
}

export const CreateUserDto: MessageFns<
  CreateUserDto,
  "api.users.CreateUserDto"
> = {
  $type: "api.users.CreateUserDto" as const,

  encode(
    message: CreateUserDto,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.username !== undefined) {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserDto {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserDto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(CreateUserDto.$type, CreateUserDto);

function createBaseTokenPayload(): TokenPayload {
  return { $type: "api.users.TokenPayload", userId: "", email: "" };
}

export const TokenPayload: MessageFns<TokenPayload, "api.users.TokenPayload"> =
  {
    $type: "api.users.TokenPayload" as const,

    encode(
      message: TokenPayload,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.userId !== "") {
        writer.uint32(10).string(message.userId);
      }
      if (message.email !== "") {
        writer.uint32(18).string(message.email);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TokenPayload {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTokenPayload();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.email = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

messageTypeRegistry.set(TokenPayload.$type, TokenPayload);

function createBaseProfile(): Profile {
  return {
    $type: "api.users.Profile",
    id: 0,
    userId: 0,
    bio: "",
    location: "",
    website: "",
  };
}

export const Profile: MessageFns<Profile, "api.users.Profile"> = {
  $type: "api.users.Profile" as const,

  encode(
    message: Profile,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    if (message.bio !== "") {
      writer.uint32(26).string(message.bio);
    }
    if (message.location !== "") {
      writer.uint32(34).string(message.location);
    }
    if (message.website !== "") {
      writer.uint32(42).string(message.website);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Profile {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(Profile.$type, Profile);

function createBaseCreateProfileDto(): CreateProfileDto {
  return {
    $type: "api.users.CreateProfileDto",
    userId: 0,
    bio: "",
    location: "",
    website: "",
  };
}

export const CreateProfileDto: MessageFns<
  CreateProfileDto,
  "api.users.CreateProfileDto"
> = {
  $type: "api.users.CreateProfileDto" as const,

  encode(
    message: CreateProfileDto,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId);
    }
    if (message.bio !== "") {
      writer.uint32(18).string(message.bio);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    if (message.website !== "") {
      writer.uint32(34).string(message.website);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProfileDto {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProfileDto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.website = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(CreateProfileDto.$type, CreateProfileDto);

function createBaseEmpty(): Empty {
  return { $type: "api.users.Empty" };
}

export const Empty: MessageFns<Empty, "api.users.Empty"> = {
  $type: "api.users.Empty" as const,

  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(Empty.$type, Empty);

function createBaseGetUsersResponse(): GetUsersResponse {
  return { $type: "api.users.GetUsersResponse", users: [] };
}

export const GetUsersResponse: MessageFns<
  GetUsersResponse,
  "api.users.GetUsersResponse"
> = {
  $type: "api.users.GetUsersResponse" as const,

  encode(
    message: GetUsersResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetUsersResponse.$type, GetUsersResponse);

function createBaseGetCurrentUserRequest(): GetCurrentUserRequest {
  return { $type: "api.users.GetCurrentUserRequest" };
}

export const GetCurrentUserRequest: MessageFns<
  GetCurrentUserRequest,
  "api.users.GetCurrentUserRequest"
> = {
  $type: "api.users.GetCurrentUserRequest" as const,

  encode(
    message: GetCurrentUserRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetCurrentUserRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetCurrentUserRequest.$type, GetCurrentUserRequest);

function createBaseGetCurrentUserResponse(): GetCurrentUserResponse {
  return { $type: "api.users.GetCurrentUserResponse", id: 0, email: "" };
}

export const GetCurrentUserResponse: MessageFns<
  GetCurrentUserResponse,
  "api.users.GetCurrentUserResponse"
> = {
  $type: "api.users.GetCurrentUserResponse" as const,

  encode(
    message: GetCurrentUserResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.username !== undefined) {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.avatar !== undefined) {
      writer.uint32(34).string(message.avatar);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetCurrentUserResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetCurrentUserResponse.$type, GetCurrentUserResponse);

function createBaseGetUserByEmailRequest(): GetUserByEmailRequest {
  return { $type: "api.users.GetUserByEmailRequest", email: "" };
}

export const GetUserByEmailRequest: MessageFns<
  GetUserByEmailRequest,
  "api.users.GetUserByEmailRequest"
> = {
  $type: "api.users.GetUserByEmailRequest" as const,

  encode(
    message: GetUserByEmailRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetUserByEmailRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetUserByEmailRequest.$type, GetUserByEmailRequest);

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return { $type: "api.users.UpdateUserRequest" };
}

export const UpdateUserRequest: MessageFns<
  UpdateUserRequest,
  "api.users.UpdateUserRequest"
> = {
  $type: "api.users.UpdateUserRequest" as const,

  encode(
    message: UpdateUserRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.query !== undefined) {
      TokenPayload.encode(message.query, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      ReceivedRefreshToken.encode(
        message.data,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = TokenPayload.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = ReceivedRefreshToken.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(UpdateUserRequest.$type, UpdateUserRequest);

function createBaseReceivedRefreshToken(): ReceivedRefreshToken {
  return { $type: "api.users.ReceivedRefreshToken", refreshToken: "" };
}

export const ReceivedRefreshToken: MessageFns<
  ReceivedRefreshToken,
  "api.users.ReceivedRefreshToken"
> = {
  $type: "api.users.ReceivedRefreshToken" as const,

  encode(
    message: ReceivedRefreshToken,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ReceivedRefreshToken {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceivedRefreshToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(ReceivedRefreshToken.$type, ReceivedRefreshToken);

/** Users specific messages */

export interface UsersServiceClient {
  getUsers(request: Empty): Observable<GetUsersResponse>;

  getCurrentUser(
    request: GetCurrentUserRequest,
  ): Observable<GetCurrentUserResponse>;

  createProfile(request: CreateProfileDto): Observable<Profile>;

  createUser(request: CreateUserDto): Observable<User>;

  getOrCreateUser(request: CreateUserDto): Observable<User>;

  getUserByEmail(request: GetUserByEmailRequest): Observable<User>;

  updateUser(request: UpdateUserRequest): Observable<User>;
}

/** Users specific messages */

export interface UsersServiceController {
  getUsers(
    request: Empty,
  ):
    | Promise<GetUsersResponse>
    | Observable<GetUsersResponse>
    | GetUsersResponse;

  getCurrentUser(
    request: GetCurrentUserRequest,
  ):
    | Promise<GetCurrentUserResponse>
    | Observable<GetCurrentUserResponse>
    | GetCurrentUserResponse;

  createProfile(
    request: CreateProfileDto,
  ): Promise<Profile> | Observable<Profile> | Profile;

  createUser(request: CreateUserDto): Promise<User> | Observable<User> | User;

  getOrCreateUser(
    request: CreateUserDto,
  ): Promise<User> | Observable<User> | User;

  getUserByEmail(
    request: GetUserByEmailRequest,
  ): Promise<User> | Observable<User> | User;

  updateUser(
    request: UpdateUserRequest,
  ): Promise<User> | Observable<User> | User;
}

export function UsersServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getUsers",
      "getCurrentUser",
      "createProfile",
      "createUser",
      "getOrCreateUser",
      "getUserByEmail",
      "updateUser",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod("UsersService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod("UsersService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const USERS_SERVICE_NAME = "UsersService";

export interface MessageFns<T, V extends string> {
  readonly $type: V;

  encode(message: T, writer?: BinaryWriter): BinaryWriter;

  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
